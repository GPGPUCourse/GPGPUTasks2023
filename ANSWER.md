# Задача 1

## Условие

Пусть на вход дан сигнал x[n], а на выход нужно дать два сигнала y1[n] и y2[n]:

```
 y1[n] = x[n - 1] + x[n] + x[n + 1]
 y2[n] = y2[n - 2] + y2[n - 1] + x[n]
```

Какой из двух сигналов будет проще и быстрее реализовать в модели массового параллелизма на GPU и почему?

## Решение

`y1[n]` можно посчитать независимо друг от друга, обращаясь только к `x[...]`,
поэтому их можно посчитать параллельно.

`y2[n]` зависит от `y2[0], ..., y2[n - 1]`, поэтому посчитать их независимо нельзя,
как нельзя и достичь большей скорости, чем при последовательном подсчёте за линейное время на CPU.

Таким образом, `y1[n]` будет проще и быстрее реализовать в модели массового параллелизма, чем `y2[n]`.

# Задача 2

## Условие

Предположим что размер warp/wavefront равен 32 и рабочая группа делится на warp/wavefront-ы таким образом что внутри warp/wavefront номер WorkItem по оси x меняется чаще всего, затем по оси y и затем по оси z.

Напоминание: инструкция исполняется (пусть и отмаскированно) в каждом потоке warp/wavefront если хотя бы один поток выполняет эту инструкцию неотмаскированно. Если не все потоки выполняют эту инструкцию неотмаскированно - происходит т.н. code divergence.

Пусть размер рабочей группы (32, 32, 1)

```c
int idx = get_local_id(1) + get_local_size(1) * get_local_id(0);
if (idx % 32 < 16)
    foo();
else
    bar();
```

Произойдет ли code divergence? Почему?

## Решение

Подставим константы:

```c
int idx = local_y + 32 * local_x;
if (idx % 32 < 16)
    foo();
else
    bar();
```

Можно заметить, что `local_x` не будет влиять на остаток от деления на 32, поэтому код можно представить как:

```c
if (local_y % 32 < 16)
    foo();
else
    bar();
```

То есть на выбор ветви исполнения влияет только `local_y`, но не `local_x`.
Поскольку размер warp равен 32, размер рабочей группы — (32, 32, 1), а номер по оси `x` меняется чаще всего,
то в пределах одного warp'а у потоков будет разным только `local_x`, а `local_y` будет одинаковым.

Следовательно, все потоки будут выполнять одну и ту же ветку,
**code divergence не произойдёт.**

# Задача 3

## Условие

Как и в прошлом задании предположим что размер warp/wavefront равен 32 и рабочая группа делится на warp/wavefront-ы таким образом что внутри warp/wavefront номер WorkItem по оси x меняется чаще всего, затем по оси y и затем по оси z.

Пусть размер рабочей группы (32, 32, 1).
Пусть data - указатель на массив float-данных в глобальной видеопамяти идеально выравненный (выравнен по 128 байтам, т.е. data % 128 == 0). И пусть размер кеш линии - 128 байт.

(a)
```
data[get_local_id(0) + get_local_size(0) * get_local_id(1)] = 1.0f;
```

Будет ли данное обращение к памяти coalesced? Сколько кеш линий записей произойдет в одной рабочей группе?

(b)
```
data[get_local_id(1) + get_local_size(1) * get_local_id(0)] = 1.0f;
```

Будет ли данное обращение к памяти coalesced? Сколько кеш линий записей произойдет в одной рабочей группе?

(c)
```
data[1 + get_local_id(0) + get_local_size(0) * get_local_id(1)] = 1.0f;
```

Будет ли данное обращение к памяти coalesced? Сколько кеш линий записей произойдет в одной рабочей группе?

## Решение

Также, как и в предыдущей задаче, заметим, что у всех потоках в одном warp'е
будет различаться `local_x = get_local_id(0)`, а `local_y = get_local_id(1)` будет одинаковым.
При этом оба значения находятся в диапазоне от 0 до 31 включительно.

Размер float — 4 байта, поэтому кеш-линия в 128 байт — это 32 float'а,
при этом массив `data` выровнен по кеш-линии, следовательно, все ячейки
`data[32 * k + 0], ..., data[32 * k + 31]`
находятся на одной кеш-линии.

### Пункт (a)

В одном warp'е обращения происходят к ячейкам
`data[0 + 32 * local_y], ..., data[31 + 32 * local_y]`,
`local_y` у потоков warp'а одинаковый,
поэтому все обращения произойдут к одной и той же кеш-линии.
Такое обращение к памяти — **coalesced**.

В рабочей группе будут 32 различных значения `local_y`,
следовательно, будет записано **32 кеш-линии.**

### Пункт (b)

В одном warp'е обращения происходят к ячейкам
`data[local_y + 32 * 0], ..., data[local_y + 32 * 31]`.
Все эти обращения — к разным кеш-линиям,
такое обращение — **не coalesced.**

Более того, обращения будут сериализованы, если локальная память делится на 32 memory bank'а с шагом в 4 байта,
поскольку тогда все потоки будут обращаться в один и тот же memory bank.

Рабочая группа обращается к 32 различным кеш-линиям, но к каждой из них — одновременно,
поэтому из-за выгрузок кеша можно ожидать, что каждая из 32 кеш-линий будет записана по 32 раза,
всего — **1024 записи.**

### Пункт (c)

В одном warp'е обращения происходят к ячейкам
`data[1 + 32 * local_y], ..., data[32 + 32 * local_y]`,
т.е. 31 ячейка из одной кеш-линии и 1 — из другой.
Такое обращение к памяти — **не coalesced.**

Рабочая группа обращается к 33 различным кеш-линиям, скорее всего каждая из них будет загружена и выгружена по одному разу,
поэтому всего будет **33 записи.**
