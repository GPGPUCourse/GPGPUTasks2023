**1)** Первый сигнал будет гораздо проще реализовать, т.к как сигнал x[n] нам уже известен и мы легко распараллелим вычисления y1[n] для всех n. Второй сигнал требует на каждом шаге результаты предыдущих вычислений -- его распараллелить не получится.

**2)** get_local_size(1) равен 32, а значит правая часть idx всегда делится на 32 и мы можем заменить предикат на get_local_id(1) < 16. То есть get_local_id, который меняется чаще всего, никак не влияет на задачу.
И внутри варпа все потоки будут выполнять задачу с одинаковым get_local_id, то есть имень одинаковую инструкцию и code divergence не произойдёт.

**3)**
(a) Да, такое обращение будет coalesced. Внутри варпа мы получим обращение к data и индексами 32 * i -- 32 * i + 31. Они находятся рядом в памяти (подряд), а значит достигнутая скорость будет максимальной. Произойдёт одна кеш линия записи на каждый варп (размер варпа 32, размер float 4 байта, 128 байт - как раз размер кеш линии). То есть всего 32 кеш линии.

(b) В этом случае обращение не будет coalesced, т.к. мы обращаемся к индексам j + 32 * 0 -- j + 32 * 31. То есть варп обращается не к соседним элементам data. Более того расстояние между ближайшими элементами в памяти 32 * sizeof(float) - 128 байт, то есть никакие два элемента не вмещаются в одну кеш линию. Значит для каждого элемента внутри варпа будет подгружена своя кеш линия - всего 32 * 32 = 1024 кеш линии.

(c) Случай похож на первый, обращение будет coalesced. Внутри варпа мы получим обращение к data и индексами 1 + 32 * i -- 1 + 32 * i + 31. Случай отличается от (а) тем, что нам придётся подгружать отдельную кеш линию для последнего элемента, он не выравнен по предыдущим 128 байтам. То есть в одном варпе будет подгружено 2 кеш линии - всего 2 * 32 = 64.
