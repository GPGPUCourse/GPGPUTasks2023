# 1

> Пусть на вход дан сигнал x[n], а на выход нужно дать два сигнала y1[n] и y2[n]:
> ```C
> y1[n] = x[n - 1] + x[n] + x[n + 1]
> y2[n] = y2[n - 2] + y2[n - 1] + x[n]
> ```
> Какой из двух сигналов будет проще и быстрее реализовать в модели массового параллелизма на GPU и почему?

// не знаю, как оно будет работать при `n=0` или `n=1`, ну да ладно

Второй сигнал предполагает собой, что для `n`-ого элемента необходимо, чтобы уже были предпосчитаны `n-1`-ый и `n-2`-ой.
Это требует последовательного выполнения вычислений, что противоречит параллелизму.

В связи с этим первый сигнал, который способен считать каждый из `y1` независимо друг от друга, 
будет лучшим кандидатом для реализации на видеокарте.

# 2
> Пусть размер рабочей группы (32, 32, 1)
> ```C
> int idx = get_local_id(1) + get_local_size(1) * get_local_id(0);
> if (idx % 32 < 16)
>     foo();
> else
>     bar();
> ```
> Произойдет ли code divergence? Почему?

Как понятно из кода, `idx % 32` принимает значение `get_local_id(1)` (`get_local_size = 32`).  
Таким образом, выполнение `if` будет одновременно для всей строки: `y` (он же `local_id(1)`) одинаков для всей рабочей группы.

# 3
> Как и в прошлом задании предположим что размер warp/wavefront равен 32 и рабочая группа делится на warp/wavefront-ы таким образом что внутри warp/wavefront номер WorkItem по оси x меняется чаще всего, затем по оси y и затем по оси z.
> 
> Пусть размер рабочей группы (32, 32, 1). Пусть data - указатель на массив float-данных в глобальной видеопамяти идеально выравненный (выравнен по 128 байтам, т.е. data % 128 == 0). И пусть размер кеш линии - 128 байт.

## (a)
> ```C
> data[get_local_id(0) + get_local_size(0) * get_local_id(1)] = 1.0f;
> ```
>
> Будет ли данное обращение к памяти coalesced? Сколько кеш линий записей произойдет в одной рабочей группе?

Одновременное обращение будет к последовательным 128 байтам. Обращение к памяти coalesced.  
Одна рабочая группа подгрузит их 32 раза.

## (b)
> ```C
> data[get_local_id(1) + get_local_size(1) * get_local_id(0)] = 1.0f;
> ```
>
> Будет ли данное обращение к памяти coalesced? Сколько кеш линий записей произойдет в одной рабочей группе?

Будет одновременное обращение к байтам `№№0, 32, 64,...`. 
На каждый запрос в пределах этого одновременного обращения в кэш необходимо загрузить кеш линию, всего `32` раз. 
Обращение к памяти не coalesced.  
Одна рабочая группа будет подгружать кеш линию `32*32=1024` раз.

## (c)
> ```C
> data[1 + get_local_id(0) + get_local_size(0) * get_local_id(1)] = 1.0f;
> ```
>
> Будет ли данное обращение к памяти coalesced? Сколько кеш линий записей произойдет в одной рабочей группе?

Одновременное обращение будет к последовательным 128 байтам, но к номерам от `4` и до `131`.
Последние 4 байта лежат в следующей странице, поэтому подгрузят следующую кеш линию.  
Обращение к памяти не coalesced.  
Таким образом, на каждую строку в рабочей группе происходят `2` записи, и всего `64` записи.