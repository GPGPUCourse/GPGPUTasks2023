# Задание 2. Теоретическое задание: параллелизуемость/code divergence/memory coalesced access

**1)** Пусть на вход дан сигнал x[n], а на выход нужно дать два сигнала y1[n] и y2[n]:

```
 y1[n] = x[n - 1] + x[n] + x[n + 1]
 y2[n] = y2[n - 2] + y2[n - 1] + x[n]
```

Какой из двух сигналов будет проще и быстрее реализовать в модели массового параллелизма на GPU и почему?

__Решение:__
1) Для получения сигнала x поток будет задействовать память почти всегда из одной кеш-линии.\
   Кроме того, поток будет запрашивать данные из разных банков. \
   Память y1 может быть write-only, а в каждую ячейку будет писать только один поток. \
   Все это даст высокую производительность.
2) Для вычисления сигнала y2 нужно знать 2 предыдущих значения y2. \
   Поэтому вычислять параллельно не возможно. Можно посчитать только последовательно. \
   Если все таки пробовать вычислить y2 на GPU, то надо будет синхронизировать вычисления так, чтобы к моменту вычисления y2[i], были посчитаны y2[i-1], y2[i-2].

__Ответ:__ y1.



**2)** Предположим что размер warp/wavefront равен 32 и рабочая группа делится
на warp/wavefront-ы таким образом что внутри warp/wavefront
номер WorkItem по оси x меняется чаще всего, затем по оси y и затем по оси z.

Пусть размер рабочей группы (32, 32, 1)

```
int idx = get_local_id(1) + get_local_size(1) * get_local_id(0);
if (idx % 32 < 16)
    foo();
else
    bar();
```

Произойдет ли code divergence? Почему?

__Решение:__

Так как размер рабочей группы (32, **32**, 1), то get_local_size(1) будет равен 32.

```
idx = y + 32 * x
idx % 32 == y % 32
```

Чаще всего изменяется x, значит в пределах одного варпа будет один и тот же y. \
Поэтому все потоки пойдут либо по одной, либо по другой ветке if.\
Значит code divergence не произойдет, и никакие потоки не будут грустить.

__Ответ__: code divergence не произойдет.



**3)** Как и в прошлом задании предположим что размер warp/wavefront равен 32 и рабочая группа делится
на warp/wavefront-ы таким образом что внутри warp/wavefront
номер WorkItem по оси x меняется чаще всего, затем по оси y и затем по оси z.

Пусть размер рабочей группы (32, 32, 1).
Пусть data - указатель на массив float-данных в глобальной видеопамяти идеально выравненный (выравнен по 128 байтам, т.е. data % 128 == 0). И пусть размер кеш линии - 128 байт.

(a)
```
data[get_local_id(0) + get_local_size(0) * get_local_id(1)] = 1.0f;
```

Будет ли данное обращение к памяти coalesced? Сколько кеш линий записей произойдет в одной рабочей группе?

__Решение:__

Так как, x изменяется быстрее всего, то `data[x + 32 * y]` имеет постоянное смещение (32 * y) в пределах одного варпа. \
Изменение x линейно, значит будет значит будет **coalesced** обращение к памяти.

`32 * sizeof(float) = 128` - размер данных, обрабатываемых варпом, равен размеру кеш-линии. \
Для того, чтобы покрыть этот линейный участок памяти, достаточно **одной кеш-линии**.

Значит в рабочей группе произойдет **32 записи кеш-линий**.

(b)
```
data[get_local_id(1) + get_local_size(1) * get_local_id(0)] = 1.0f;
```

Будет ли данное обращение к памяти coalesced? Сколько кеш линий записей произойдет в одной рабочей группе?

__Решение:__

Рассмотрю обращение к `data[y + 32 * x]`. \
Из-за того, что x изменяется чаще всего, потоки варпа будут обращаться по адресам с шагом в `32 * sizeof(float) = 128` байт.
Такое обращение к памяти **не будет coalesced**. \
Эти ячейки памяти не могут попасть в одну и ту же кеш-линию. \
Получается, будет записано **32 кеш-линии** во время одной итерации варпа.

Значит в одной рабочей группе произойдет 32*32 = **1024 записи кеш-линий**.

(c)
```
data[1 + get_local_id(0) + get_local_size(0) * get_local_id(1)] = 1.0f;
```

Будет ли данное обращение к памяти coalesced? Сколько кеш линий записей произойдет в одной рабочей группе?

__Решение:__

Обращение к `data[1 + x + 32 * y]` имеет константное смещение 1.
При этом x растет чаще всего и участки памяти будут линейны. Значит обращение к памяти **будет coalesced**. \
На каждой итерации работы варпа, кроме последней, будет записана **одна кеш-линия**. \
А на последней итерации работы варпа, будут записаны 2 кеш-линии. \
Итого будут записаны **33 кеш-линии**.
