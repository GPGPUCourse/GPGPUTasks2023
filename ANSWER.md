# Task 1

Пусть на вход дан сигнал x[n], а на выход нужно дать два сигнала y1[n] и y2[n]:

```
 y1[n] = x[n - 1] + x[n] + x[n + 1]
 y2[n] = y2[n - 2] + y2[n - 1] + x[n]
```

Какой из двух сигналов будет проще и быстрее реализовать в модели массового параллелизма на GPU и почему?

## Решение

Сигнал y1[n] рассчитывается как сумма x[n - 1], x[n], и x[n + 1], что позволяет каждому воркеру (или потоку исполнения на GPU) обрабатывать каждый элемент независимо и параллельно, без необходимости синхронизации с другими воркерами. Это делает его подходящим кандидатом для массового параллелизма и, следовательно, более эффективным в реализации на GPU.

С другой стороны, каждый элемент y2[n] зависит от двух предыдущих элементов (y2[n - 1] и y2[n - 2]) и текущего входного сигнала x[n]. Это означает, что вычисление каждого элемента y2[n] требует результатов предыдущих вычислений, что приводит к необходимости последовательного выполнения и, следовательно, ограничивает возможности для параллельной обработки.

Следовательно сигнал y1[n] будет проще и быстрее реализовать в модели массового параллелизма на GPU по сравнению с сигналом y2[n] 

# Task 2

Предположим что размер warp/wavefront равен 32 и рабочая группа делится
 на warp/wavefront-ы таким образом что внутри warp/wavefront
 номер WorkItem по оси x меняется чаще всего, затем по оси y и затем по оси z.

Напоминание: инструкция исполняется (пусть и отмаскированно) в каждом потоке warp/wavefront если хотя бы один поток выполняет эту инструкцию неотмаскированно. Если не все потоки выполняют эту инструкцию неотмаскированно - происходит т.н. code divergence.

Пусть размер рабочей группы (32, 32, 1)

```
int idx = get_local_id(1) + get_local_size(1) * get_local_id(0);
if (idx % 32 < 16)
    foo();
else
    bar();
```

Произойдет ли code divergence? Почему?

## Решение

Так как get_local_size(1) вернёт 32, то остаток от деления idx будет зависеть только от get_local_id(1), то есть значение по оси y. 
В условии сказано, что номер WorkItem меняется сначала по оси x, следовательно все воркеры будут идти по одной ветке, т.к. размер пространства по оси x равно 32, т.е. у них будет одинаковое значение get_local_id(1).

# Task 3
Как и в прошлом задании предположим что размер warp/wavefront равен 32 и рабочая группа делится на warp/wavefront-ы таким образом что внутри warp/wavefront номер WorkItem по оси x меняется чаще всего, затем по оси y и затем по оси z.

Пусть размер рабочей группы (32, 32, 1).
Пусть data - указатель на массив float-данных в глобальной видеопамяти идеально выравненный (выравнен по 128 байтам, т.е. data % 128 == 0). И пусть размер кеш линии - 128 байт.

**(a)**
```
data[get_local_id(0) + get_local_size(0) * get_local_id(1)] = 1.0f;
```

Будет ли данное обращение к памяти coalesced? Сколько кеш линий записей произойдет в одной рабочей группе?

### Решение

Обращение к памяти в этом случае будет coalesced, поскольку каждый поток внутри warp'а обращается к последовательным адресам памяти (первый поток внутри warp'а к первому элемнту, второй ко второму и так далее). Так как размер кеш-линии — 128 байт, а размер float — 4 байта, в одной кеш-линии умещается 32 элемента float. Поскольку рабочая группа потребует 32 итерации для warp'а, каждая итерация выполняет 1 запись кеш-линии, всего будет выгружено 32 кеш-линии.

**(b)**
```
data[get_local_id(1) + get_local_size(1) * get_local_id(0)] = 1.0f;
```

Будет ли данное обращение к памяти coalesced? Сколько кеш линий записей произойдет в одной рабочей группе?

### Решение

В этом случае обращение к памяти не будет coalesced. Каждый поток в warp'е будет обращаться к различным кеш-линиям (каждый поток внутри warp'а обращается к данным из разных кеш-линий), что приведет к тому, что для каждого обращения потребуется загрузка новой кеш-линии. Таким образом, количество кеш-линий, которые будут записаны, составит 32×32=1024 кеш-линии - 32 на итерацию.

**(c)**
```
data[1 + get_local_id(0) + get_local_size(0) * get_local_id(1)] = 1.0f;
```

Будет ли данное обращение к памяти coalesced? Сколько кеш линий записей произойдет в одной рабочей группе?

### Решение 

Обращение к памяти в этом случае также не будет coalesced из-за смещения на единицу. Это приведет к тому, что каждая запись потребует загрузки 2 кеш-линии - первые 31 элемента data в одной кеш-линии и 1 из другой. Это может потребовать 64 выгрузки кеш-линии для одной рабочей группы, однако возможно и то, что потребуется всего 33 выгрузки, если след. итерация внутри warp будет использовать данные из выгруженного кеша последним потоком пред. итерации. 
