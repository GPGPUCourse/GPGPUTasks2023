**1)** Пусть на вход дан сигнал x[n], а на выход нужно дать два сигнала y1[n] и y2[n]:

```
 y1[n] = x[n - 1] + x[n] + x[n + 1]
 y2[n] = y2[n - 2] + y2[n - 1] + x[n]
```

Какой из двух сигналов будет проще и быстрее реализовать в модели массового параллелизма на GPU и почему?

**Решение**: `y1[i]` можно вычислять независимо от результатов вычислений других `y1[j]`, поэтому его просто реализовать параллельно. Для вычисления `y2[i]` требуются вычисленные предыдущие значения `y2[i - 2]` и `y2[i - 1]`, из-за чего единственным возможным вариантов вычисления `y2` является последовательное вычисление.



**2)** Предположим что размер warp/wavefront равен 32 и рабочая группа делится
 на warp/wavefront-ы таким образом что внутри warp/wavefront
 номер WorkItem по оси x меняется чаще всего, затем по оси y и затем по оси z.

Напоминание: инструкция исполняется (пусть и отмаскированно) в каждом потоке warp/wavefront если хотя бы один поток выполняет эту инструкцию неотмаскированно. Если не все потоки выполняют эту инструкцию неотмаскированно - происходит т.н. code divergence.

Пусть размер рабочей группы (32, 32, 1)

```
int idx = get_local_id(1) + get_local_size(1) * get_local_id(0);
if (idx % 32 < 16)
    foo();
else
    bar();
```

Произойдет ли code divergence? Почему?

**Решение**: Если номер WorkItem меняется по оси x чаще всего, тогда рабочая группа разделится на варпы так, что внутри варпа все 32 item'а будут иметь равный y. Отсюда `idx` внутри варпа у всех потоков будет кратным 32, т.к. `get_local_size(1)` вернет 32. Отсюда все потоки всегда будут выполнять первую ветку if'а, и code divergence не произойдет.




**3)** Как и в прошлом задании предположим что размер warp/wavefront равен 32 и рабочая группа делится
 на warp/wavefront-ы таким образом что внутри warp/wavefront
 номер WorkItem по оси x меняется чаще всего, затем по оси y и затем по оси z.

Пусть размер рабочей группы (32, 32, 1).
Пусть data - указатель на массив float-данных в глобальной видеопамяти идеально выравненный (выравнен по 128 байтам, т.е. data % 128 == 0). И пусть размер кеш линии - 128 байт.

(a)
```
data[get_local_id(0) + get_local_size(0) * get_local_id(1)] = 1.0f;
```

Будет ли данное обращение к памяти coalesced? Сколько кеш линий записей произойдет в одной рабочей группе?


**Решение**: Внутри варпа `get_local_id(0)` меняется от 0 до 31, `get_local_id(1)` - константа. Отсюда внутри варпа обращения `get_local_id(0) + get_local_size(0) * get_local_id(1)` будут к выравненному последовательному куску из 32 float, что занимает 128 байт. Отсюда обращение к памяти coalesced и будет 32 записи кеш линий внутри рабочей группы.


(b)
```
data[get_local_id(1) + get_local_size(1) * get_local_id(0)] = 1.0f;
```

Будет ли данное обращение к памяти coalesced? Сколько кеш линий записей произойдет в одной рабочей группе?

**Решение**: Обращения `get_local_id(0) + get_local_size(0) * get_local_id(1)` будут происходить к элементам с шагом 32, что не является coalesced, и приведет к 32*32 записям кэш линий.

(c)
```
data[1 + get_local_id(0) + get_local_size(0) * get_local_id(1)] = 1.0f;
```

Будет ли данное обращение к памяти coalesced? Сколько кеш линий записей произойдет в одной рабочей группе?

**Решение**: Обращения `1 + get_local_id(0) + get_local_size(0) * get_local_id(1)` похожи на обращения из первого пункта, но тут добавляется `+ 1`. Отсюда первые 31 обращения будут внутри отдной кэш линии, а 32-ое обращение потребует записи второй кэш линии. Но это все еще можно назвать coalesced обращением. Записей кэш линий всего будет 64.