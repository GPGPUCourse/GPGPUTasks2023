# ОТВЕТЫ - Задание 2. Теоретическое задание: параллелизуемость/code divergence/memory coalesced access
**1)** Пусть на вход дан сигнал x[n], а на выход нужно дать два сигнала y1[n] и y2[n]:

```
 y1[n] = x[n - 1] + x[n] + x[n + 1]
 y2[n] = y2[n - 2] + y2[n - 1] + x[n]
```

Какой из двух сигналов будет проще и быстрее реализовать в модели массового параллелизма на GPU и почему?

**ОТВЕТ**

Сигнал `y1`, т.к. там нет рекуррентных зависимостей, и мы сможем разбить задачу, раздав каждому work-item'у независимую задачку. Для любого `n` сигнал `y1[n]` посчитать можно за O(1), в то время как подсчет сигнала `y2[n]` займет O(n) операций.

---

**2)** Предположим что размер warp/wavefront равен 32 и рабочая группа делится
 на warp/wavefront-ы таким образом что внутри warp/wavefront
 номер WorkItem по оси x меняется чаще всего, затем по оси y и затем по оси z.

Напоминание: инструкция исполняется (пусть и отмаскированно) в каждом потоке warp/wavefront если хотя бы один поток выполняет эту инструкцию неотмаскированно. Если не все потоки выполняют эту инструкцию неотмаскированно - происходит т.н. code divergence.

Пусть размер рабочей группы (32, 32, 1)

```
int idx = get_local_id(1) + get_local_size(1) * get_local_id(0);
if (idx % 32 < 16)
    foo();
else
    bar();
```

Произойдет ли code divergence? Почему?

**ОТВЕТ**

В такой посстановке, наша рабочая группа возьмет себе 32 Warp'а, каждый из которых будет обрабатывать по строчке из рабочей группы. Тогда:
* `get_local_id(1)` внутри одного Warp'а будет одним и тем же (в промежутке от 0 до 31);
* `get_local_size(1)` = 32, из размера рабочей группы;
* `get_local_id(0)` будет принимать значения от 0 до 31, свое для каждого work-item'а, единственная величина, которая вообще будет меняться.

Тогда, в вычислении `idx` второе слагаемое по модулю 32 даст 0, и то, в какую ветку будут заходить все work-item'ы одного Warp'а будет однозначно определено первым слагаемым.
*Значит, Code Divergence не произойдет.*

---

**3)** Как и в прошлом задании предположим что размер warp/wavefront равен 32 и рабочая группа делится
 на warp/wavefront-ы таким образом что внутри warp/wavefront
 номер WorkItem по оси x меняется чаще всего, затем по оси y и затем по оси z.

Пусть размер рабочей группы (32, 32, 1).
Пусть data - указатель на массив float-данных в глобальной видеопамяти идеально выравненный (выравнен по 128 байтам, т.е. data % 128 == 0). И пусть размер кеш линии - 128 байт.

(a)
```
data[get_local_id(0) + get_local_size(0) * get_local_id(1)] = 1.0f;
```
Будет ли данное обращение к памяти coalesced? Сколько кеш линий записей произойдет в одной рабочей группе?

**ОТВЕТ:** обращение coalesced, т.к. соседние work-item'ы стучатся по соседним индексам (n, n+1, n+2, etc.).

Размер float - 4 байта, значит в одной кеш линии будет записываться 128 / 4 = 32 элемента, которые будут идеально ложиться на 32 элемента warp'а. Получается один варп - одна кеш линия, еще и потому, что у нас нет сдвига, и данные выравнены. Тогда для нашей рабочей группы потребуется 32 кеш-линии записей.

(b)
```
data[get_local_id(1) + get_local_size(1) * get_local_id(0)] = 1.0f;
```
Будет ли данное обращение к памяти coalesced? Сколько кеш линий записей произойдет в одной рабочей группе?

**ОТВЕТ:** обращение не coalesced, т.к. соседние work-item'ы стучатся по индексам (`[C + 32*n], [C + 32*(n + 1)], [C + 32*(n + 2)]`, etc.), а они совсем не соседние, они находятся на расстоянии в 32 элемента друг от друга, а значит даже 2 соседних элемента не влезут в одну кеш линию.

Для записи одного элемента потребуется использовать всю кеш-линию. Всего элементов 32*32, столько же кеш-линий и потребуется.

(c)
```
data[1 + get_local_id(0) + get_local_size(0) * get_local_id(1)] = 1.0f;
```

Будет ли данное обращение к памяти coalesced? Сколько кеш линий записей произойдет в одной рабочей группе?

**ОТВЕТ:** обращение coalesced, соседние work-item'ы стучатся в соседние ячейки.

Однако, т.к. изначально данные были выравнены, то сдвиг в 4 байта нам немного попортил доступ, и последнему work-item'у для записи нужна будет индивидуальная кеш линия.

Итого потребуется 32*2 кеш линий.
