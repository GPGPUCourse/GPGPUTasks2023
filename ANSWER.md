# Задача 1

Проще будет реализовать сигнал `y1`, так как его вычисления можно безбоязненно 
параллелизовать, в то время как сигнал `y2` для своих вычислений требует свои же 
предыдущие значения, т.е. $\forall$ `i` мы можем вычислить `y1[i]` в любой момент 
времени, а чтобы вычислить `y2[i]`, нам нужно знать `y2[i-1]` и `y2[i-2]`, а для 
них в свою очередь нужны предыдущие `y2`, из-за чего параллелилизм для `y2` сильно 
затруднен. Однако для `y2` можно найти рекуррентное соотношение:

$$y2_k = x_k + \sum\limits_{i=1}^{k}i\cdot x_{k-i}$$

Тогда `y2` можно либо найти через динамическое программирование 
(которое можно параллелизовать) или через умножение на матрицу вида:

$$ A = \begin{pmatrix}
1 & 0 & ... & 0\\
1 & 1 & ... & 0 \\
&& \vdots & \\
n & n - 1 & ... & 1
\end{pmatrix} $$

В таком случае 

$$y2 = X \cdot A$$

Умножение матриц тоже параллелизуется, однако всё равно первый сигнал считается быстрее, так как для его подсчета требуется $3n$ сложений, а для второго сигнала требуется $n^2$ умножений и столько же сложений

# Задача 2

Нет не произойдет, так как `get_local_size(1) * get_local_id(0)` по модулю 32 
всегда равняется нулю, а следовательно, на каждом варпе (поскольку его размер 
равен 32) будут выполняться только work items с одинаковым `get_local_size(1)` 
(поскольку ось x меняется чаще, чем остальные оси), а как я писал выше, второе 
слагаемое в этой сумме не будет влиять на `if`, так как по модулю 32 оно равно нулю

# Задача 3

### (а)

Да будет, так как на один варп будет подгружена всего одна кеш линия, так как в 
варпе 32 work item, следовательно, варп обратится к 32 float числам, которые лежат 
последовательно, а значит нужно будет подгрузить $4 \cdot 32=128$ байт, что является 
одной кешлинией. Следовательно, на всю рабочую группу нужно будет подгрузить 32 кеш 
линии

Последовательность обращений следует из того, что для оного варпа вот это слагаемое 
всегда одинаково `get_local_size(0) * get_local_id(1)`, так как номер work item 
сначала меняется по оси X, а затем уже по остальным осям

### (b)

А тут уже не будет, так как обращения в одном варпе будут не последовательными, 
а с интервалом в `get_local_size(1)`, т.е. 32 (так как опять же сначала меняется 
ось X, а затем уже Y), поэтому на каждый work item нужна будет отдельная кеш линия, 
следовательно, на варп понадобится 32 кеш линии, а на всю ворк группу 
$32 \cdot 32 = 1024$ кеш линий

### (c)

Строго говоря, этот код может привести в лучшем случае к падению, а в худшем к UB, 
так как мы вылезаем за границы массива data. 

На варп будет две подгрузки кеш линии (на 0-30-ый потоки - 1-ая подгрузка, 
на 31-ый - 2-ая). На всю ворк группу понадобится 64 подгрузки (если я правильно 
понял, то L1 кеш у каждого варпа свой, а значит варпы не знают о подгрузках друг 
друга, т.е. первый варп не сможет использовать подгруженную нулевым варпом кеш 
линию для своих 32-62 work item)

Если же говорить о coalesced, то ответ нет, так как мы используем ровно 50% данных 
из подгруженных кеш линий: 124 байта в первой и 4 байта во второй, а так как грузим 
мы две кеш линии, что в сумме даёт нам 256 байт, то мы использовали ровно половину.
По определению в тг, это не coalesced:
![Определение](./1.png)

