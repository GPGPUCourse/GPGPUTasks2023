## Задание 1

Первый сигнал реализовать проще, потому что вычисление каждого следующего элемента не зависит от предыдущих.

Чтобы можно было распараллелить вычисление второго, надо вывести формулу, зависищую только от `x`. В таком случае там появятся дополнительные операции --- умножения, но хотя бы можно будет вычислять параллельно.

## Задание 2

Рабочая группа разделится на 32 warp, в каждом индексация будет следующая: `(i, a, 0)`, где `i` от 0 до 31, `a` --- номер прохода warp.

То есть внутри одного прохода `get_local_id(1)` будет оставаться неизменным, а значит `idx % 32` будет константой, поэтому code divergence не произойдет.

## Задание 3

### 3.a

Да, оно будет coalesced, потому что в одном warp запрашивается 32*4=128 подряд идущих байт.

В одной рабочей группе будет записано 32 кеш-линии (по одной на warp).

### 3.b

Это обращение не будет coalesced.

На одном проходе warp будет записано 32 кеш-линии, и так 32 раза. Всего 1024 записей.

### 3.c

В первом проходе подгрузится 2 кеш-линии, но если warp будет в правильном порядке брать потоки, вторая подгруженная кеш-линия будет использована на следующем проходе. Таким образом, в удачном случае полностью не будет заиспользована только последняя подгрузка. В худшем случае на каждом проходе мы подрузим в 2 раза больше памяти, чем заиспользуем.

Обращение будет coalesced. Всего произойдет от 33 до 64 записей.