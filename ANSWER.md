### Задача 1
Быстрее и проще будет реализация для сигнала y1, потому что все значения y1[i] мы можем
посчитать паралелльно и независимо друг от друга, складывая x[i - 1], x[i], x[i + 1].
А в сигнале для y2 каждое значение выражается через взвешенную сумму первых n элементов массива
x, поэтому в реализации либо какие-то потоки будут ждать завершения работы других, чтобы
использовать их результат вычисления, либо не все потоки будут выполняться за
константное время.

### Задача 2
Нет, code divergence не произойдет. После того, как мы возьмем значение
`int idx = get_local_id(1) + get_local_size(1) * get_local_id(0)` по модулю 32,
получим `get_local_id(1)`, так как `get_local_size(1)` равен 32, а `get_local_id(1)` меньше 32.
В warp/wavefront одновременно у нас будут выполняться workItem-ы с одинаковыми номерами по оси
y, то есть, с одинаковыми значениями `get_local_id(1)`. Значит, все потоки будут заходить в
одну и ту же ветку if, и code divergence не произойдет.

### Задача 3
В пункте (a) запросы к памяти в warp/wavefront будут обращены к подряд идущим ячейкам data (у
потоков будет меняться только get_local_id(0)), которые находятся в одной кэш-линии.
Поэтому у одной рабочей группы всего будет использовано 32 кэш-линии для записи.

В пункте (b) потоки с соседними номерами будут считывать ячейки на расстоянии
`get_local_size(1) = 32` байта. Размер кэш-линии равен 128 байт, поэтому запросы к памяти
"склеиваются" у 4 соседних потоков (`128 / 32 = 4`). Всего потоков 32, поэтому в warp/wavefront 
используется 8 кэш-линий для записи, а в WG --- `8 * 32 = 256`.

В пункте (c) warp/wavefront будет записывать данные в 2 кэш-линии, так как у нас теперь, по
сравнению с пунктом (a), есть сдвиг на 1 в индексации. Значит, всего на рабочую группу будет
`2 * 32 = 64` кэш-линии для записи.