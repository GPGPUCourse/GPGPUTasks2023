**1)** y1 реализовать проще, потому что при вычислении y1 требуется знать только массив x. Поэтому в модели массового
параллелизма можно создать одинаковые потоки, где каждый поток одинаковым образом вычисляет y1[n] для каждого n. 

y2 же содержит зависимости y2[n] от y2[n - 1] и y2[n - 2]. Поэтому такой простой подход, как для y1, не будет работать 
в данном случе из-за зависимости данных 

**2)** 

```
idx = y + 32 * x

idx % 32 = y
```

Поскольку warp размера 32, а x - самая часто меняющаяся переменная, то получится, что в рамках рабочей группы каждый 
один warp будет заниматься обработкой одной строки (y = const, x - меняется). Поэтому в рамках одного warp 
`idx % 32 = y = const`, поэтому все потоки warp'а пойдут только в одно из ветвлений и code divergence не произойдёт

**3)**

(a) 

```
data[x + 32 * y]
```

да будет, потому что потоки warp'а обратятся одновременно к последовательному куску данных, находящихся в одной кэш линии.

Всего будет 32 записей кэш линий (на каждый y по одной кэш линии в 128 байт)

(b)

``` 
data[y + 32 * x]
```

Нет, не будет. Потому что потоки warp'а будут обращаться к данным, находящимся далеко друг от друга (в разных кэш линиях). 
Поэтому каждое обращение будет перезаписывать кэш линию и всего будет 32*32 записей. 

(с)
``` 
data[1 + x + 32 * y]
```

Да будет. Каждый warp обращается к последовательному куску данных. Однако в этот раз данные будут лежать не в одной кэш линии.
Поэтому каждый warp запишет 2 кэш линии и всего будет 32*2 записей. 