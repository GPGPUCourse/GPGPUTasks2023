**1)** Пусть на вход дан сигнал x[n], а на выход нужно дать два сигнала y1[n] и y2[n]:

```
 y1[n] = x[n - 1] + x[n] + x[n + 1]
 y2[n] = y2[n - 2] + y2[n - 1] + x[n]
```

Какой из двух сигналов будет проще и быстрее реализовать в модели массового параллелизма на GPU и почему?


*Ответ*: Проще будет посчитать y1, так как 
1. y1 зависит только от x и только на чтение.
2. y1 не зависит от своих предыдущих значений, т.е. все work item могут работать независимо друг от друга, чего нельзя сказать про y2.


**2)** Предположим что размер warp/wavefront равен 32 и рабочая группа делится
 на warp/wavefront-ы таким образом что внутри warp/wavefront
 номер WorkItem по оси x меняется чаще всего, затем по оси y и затем по оси z.

Напоминание: инструкция исполняется (пусть и отмаскированно) в каждом потоке warp/wavefront если хотя бы один поток выполняет эту инструкцию неотмаскированно. Если не все потоки выполняют эту инструкцию неотмаскированно - происходит т.н. code divergence.

Пусть размер рабочей группы (32, 32, 1)

```
int idx = get_local_id(1) + get_local_size(1) * get_local_id(0);
if (idx % 32 < 16)
    foo();
else
    bar();
```

Произойдет ли code divergence? Почему?

*Ответ*: get_local_size(1) = 32 по условию, значит idx % 32 = get_local_id(1). Так как чаще меняется get_local_id(0) и меняется от 0 до 31, то это значит, что у work item-ов в рамках одной рабочей группы будет одинаковый get_local_id(1), так как их как раз 32. А это значит, что idx % 32 будет одинаковый на всех work item одной рабочей группы. Значит code divergence не будет, так как все потоки будут заходить в одну ветку if.

**3)** Как и в прошлом задании предположим что размер warp/wavefront равен 32 и рабочая группа делится
 на warp/wavefront-ы таким образом что внутри warp/wavefront
 номер WorkItem по оси x меняется чаще всего, затем по оси y и затем по оси z.

Пусть размер рабочей группы (32, 32, 1).
Пусть data - указатель на массив float-данных в глобальной видеопамяти идеально выравненный (выравнен по 128 байтам, т.е. data % 128 == 0). И пусть размер кеш линии - 128 байт.

(a)
```
data[get_local_id(0) + get_local_size(0) * get_local_id(1)] = 1.0f;
```

Будет ли данное обращение к памяти coalesced? Сколько кеш линий записей произойдет в одной рабочей группе?

*Ответ*: При фиксированном y (так как х меняется чаще всего), обращение будет по 32 последовательным элементам из data, что соответствует 128 байтам (i.e. одной кэш линии). То есть обращение к памяти будет coalesced. Всего y будет менятся 32 раза, значит в рамках одной work group будет 32 кэш линии записей.

(b)
```
data[get_local_id(1) + get_local_size(1) * get_local_id(0)] = 1.0f;
```

Будет ли данное обращение к памяти coalesced? Сколько кеш линий записей произойдет в одной рабочей группе?

*Ответ*: При фиксированном y (так как х меняется чаще всего), обращение будет к 32 элементам с шагом 128 байт из data, а значит будет попадать в 32 кэш линии. То есть обращение к памяти не будет coalesced. Всего y будет менятся 32 раза, значит в рамках одной work group будет 32 * 32 = 1024 кэш линии записей.

(c)
```
data[1 + get_local_id(0) + get_local_size(0) * get_local_id(1)] = 1.0f;
```

Будет ли данное обращение к памяти coalesced? Сколько кеш линий записей произойдет в одной рабочей группе?

*Ответ*:  При фиксированном y (так как х меняется чаще всего), обращение будет к 31 элементу из одной кэш линии и 1 элементу из другой кэш линии. То есть обращение к памяти будет coalesced. Всего y будет менятся 32 раза, значит в рамках одной work group будет 32 * 2 = 64 кэш линии записей.
