В этом репозитории предложены задания для курса по вычислениям на видеокартах 2023.

[Остальные задания](https://github.com/GPGPUCourse/GPGPUTasks2023/).

Сдача задания текстом через пулл-реквест в эту ветку, созданием файла ANSWER.md.

# Задание 2. Теоретическое задание: параллелизуемость/code divergence/memory coalesced access

Ниже три небольших задачи. Рекомендуется хотя бы начать делать каждое задание к лекции 15 сентября, чтобы задать вопросы если они будут и обсудить задания. **Дедлайн**: 23:59 24 сентября.

**1)** Пусть на вход дан сигнал x[n], а на выход нужно дать два сигнала y1[n] и y2[n]:

```
 y1[n] = x[n - 1] + x[n] + x[n + 1]
 y2[n] = y2[n - 2] + y2[n - 1] + x[n]
```

Какой из двух сигналов будет проще и быстрее реализовать в модели массового параллелизма на GPU и почему?

## Ответ на задание 1

Сигнал y1 будет проще и быстрее реализовать в модели массового параллелизма на GPU, т.к. `y1[i]` не зависит от `y1[j]`. 
Иными словами, каждый "новый" ответ никак не зависит от предыдущих (здесь работает та же интуиция про `#pragma omp parallel for`).

---

**2)** Предположим что размер warp/wavefront равен 32 и рабочая группа делится
 на warp/wavefront-ы таким образом что внутри warp/wavefront
 номер WorkItem по оси x меняется чаще всего, затем по оси y и затем по оси z.

Напоминание: инструкция исполняется (пусть и отмаскированно) в каждом потоке warp/wavefront если хотя бы один поток выполняет эту инструкцию неотмаскированно. Если не все потоки выполняют эту инструкцию неотмаскированно - происходит т.н. code divergence.

Пусть размер рабочей группы (32, 32, 1)

```
int idx = get_local_id(1) + get_local_size(1) * get_local_id(0);
if (idx % 32 < 16)
    foo();
else
    bar();
```

Произойдет ли code divergence? Почему?

## Ответ на задание 2

Code divergence не произойдёт. 

Заметим, что т.к. `get_local_size(1) = (32, 32, 1)[1] = 32`, то терм `get_local_size(1) * get_local_id(0)` не играет роли в ответе на `if`. 

Остаёмся с `get_local_id(1)`, который меняется в диапазоне `[0..31]`. Однако заметим, что "быстро" меняется у нас ось `x`, которая берёт по 32 элемента. Следовательно, в рамках одного прохода warp/wavefront `get_local_id(1)` не меняется и code divergence не произойдёт.

---

**3)** Как и в прошлом задании предположим что размер warp/wavefront равен 32 и рабочая группа делится
 на warp/wavefront-ы таким образом что внутри warp/wavefront
 номер WorkItem по оси x меняется чаще всего, затем по оси y и затем по оси z.

Пусть размер рабочей группы (32, 32, 1).
Пусть data - указатель на массив float-данных в глобальной видеопамяти идеально выравненный (выравнен по 128 байтам, т.е. data % 128 == 0). И пусть размер кеш линии - 128 байт.

(a)
```
data[get_local_id(0) + get_local_size(0) * get_local_id(1)] = 1.0f;
```

Будет ли данное обращение к памяти coalesced? Сколько кеш линий записей произойдет в одной рабочей группе?

(b)
```
data[get_local_id(1) + get_local_size(1) * get_local_id(0)] = 1.0f;
```

Будет ли данное обращение к памяти coalesced? Сколько кеш линий записей произойдет в одной рабочей группе?

(c)
```
data[1 + get_local_id(0) + get_local_size(0) * get_local_id(1)] = 1.0f;
```

Будет ли данное обращение к памяти coalesced? Сколько кеш линий записей произойдет в одной рабочей группе?

## Ответ на задание 3

### (a)
```
data[get_local_id(0) + get_local_size(0) * get_local_id(1)] = 1.0f;
```
### Будет ли данное обращение к памяти coalesced?

Да, будет. По тем же рассуждениям что в задании 2: `get_local_id(0)` лежит в `[0..31]`, а `get_local_size(0) * get_local_id(1)` кратен 32 (`get_local_size(0) = 32`) и одинаков для всех в рамках warp'a (`get_local_id(1)`). 

Получаем кусок памяти, выровненный по кэшлинии (`get_local_size(0) * sizeof(float) = 128`) и обращения в него в диапазоне `[0..31]`. Следовательно по факту один warp обращается к одной кэш линии в рамках одного прохода.

### Сколько кеш линий записей произойдет в одной рабочей группе?

Т.к. в прошлом пункте показали, что один warp за один проход обращается к одной кэш-линии, и это по-сути одна строка оси x, а таких строк в рамках рабочей группы 32, то ответ - 32.

---

### (b)
```
data[get_local_id(1) + get_local_size(1) * get_local_id(0)] = 1.0f;
```
### Будет ли данное обращение к памяти coalesced?

Нет. Это самый страшный случай - в рамках одного warp/а за один проход мы обращаемся к 32-м кэш линиям. По сути, каждый "глупый поток" в рамках warp/a читает одну кэш-линию.

### Сколько кеш линий записей произойдет в одной рабочей группе?

32 * 32 * 1 = 1024

---

### (c)
```
data[1 + get_local_id(0) + get_local_size(0) * get_local_id(1)] = 1.0f;
```
### Будет ли данное обращение к памяти coalesced? 

Это то же самое что в примере (a), но один запрос вместо 0 элемента одной кэш линии будет к 0 элементу следующей. По критерию `> 50%`, данное обращение является `coalesced`.

### Сколько кеш линий записей произойдет в одной рабочей группе?

Т.к. в прошлом пункте показали, что один warp за один проход обращается к двум кэш-линиям (31 к "первой" и 1 к следующей), и это по-сути одна строка оси x, а таких строк в рамках рабочей группы 32, то ответ - (2 * 32 * 1) = 64.
