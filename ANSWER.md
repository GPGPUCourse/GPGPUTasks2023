**1)** Проще реализовать первый сигнал так как его компоненты считаются независимо (а значит их можно считать
параллельно),
в то время как для вычисления i-той компоненты второго сигнала, необходимо знать две предыдущие
(а значит такие вычисления распараллелить не получится).

**2)** Рабочая группа будет выглядеть так: <br/>

(warp 0) <br/>
(warp 1) <br/>... <br/>
(warp 31)

(Каждая строка – это новый warp/wavefront, потому что размер warp-а совпадает с размерностью рабочей группы по x).

Тогда, `get_local_size(1)` WorkItem-а совпадает с номером его warp-а (под номером warp-а я имею в виду номера из
таблички выше), а значит это значение одинаковое у всех WI в рамках warp-а.

Тогда, так как `get_local_size(1) = 32`, то в рамках одного warp-а у всех WI idx даёт одинаковый остаток при делении на
32
(и этот остаток равен `get_local_id(1)`), поэтому все WI одного warp-a попадут в одну ветку if, и code divergence не
произойдёт.

**3)** (a)
`get_local_id(0)` меняется от 0 до 31 в одном warp-e, a  `get_local_size(0) * get_local_id(1)` - константа в рамках
warp-а,
поэтому в каждом warp-е произойдёт обращение к последовательному куску памяти в 128 байт (1 кеш линия), а значит на
рабочую группу понадобится 32 кеш линии
(по одной на каждый warp). Да, это coalesced обращение.

(b)
`get_local_id(0)` константа в рамках warp-a, поэтому внутри него будут произведены такие обращения к памяти:
```data[C + 32 * 0], data[C + 32 * 1], ... data[C + 32 * 31]```
Каждое обращение требует новой кеш линии, поэтому понадобится 32 кеш линии на warp и это не coalesced обращения.
Всего понадобится 32 * 32 = 1024 кеш линии.

(c)
Здесь всё аналогично пункту (a), но теперь данные не помещаются в одну кеш линию, так как они не выровнены. Поэтому
обращения можно считать coalesced,
а кеш линий нужно 2 * 32 = 64.
