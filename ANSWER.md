## Задача 1

Первый будет реализовать проще, потому что нет зависимости $`i`$-го результата от остальных.

## Задача 2

`get_local_size(1) = 32`, `get_local_id(1) = y`, где $`y`$ одинаковый во всём warp/wavefront,
потому что «ширина» задачи совпадает с размером warp/wavefront. А `get_local_id(0)` будет
пробегать все значения от 0 до 31. Тогда $`idx = y + 32 * x, x = 0..31`$.

Очевидно, что при любом значении $`x`$ значение выражения $`32 x`$ будет делиться на 16. Тогда
делимость на 16 будет определяться значением $`y`$, которое одинаково в рамках warp/wavefront.
Поэтому code divergence не произойдёт.

## Задача 3

### Пункт (a)

В каждом warp/wavefront значение `get_local_size(0) = 32`, `get_local_id(1) = y`, где $`y`$
одинаковый, потому что, как и в предыдущей задаче, каждая строка будет выполняться целиком на
своём warp/wavefront. При этом `get_local_id(0)` будет у всех разное, от 0 до 31.
Таким образом индексы примут все значения от $`32 y`$ до $`32 y + 31`$ включительно.
Тогда все обращения попадут в одну кеш-линию. Тогда в рабочей группе будет записано 32 кеш-линии.

### Пункт (b)

- `get_local_size(1) = 32`
- `get_local_id(1) = y`
- `get_local_id(0)` у всех разный от 0 до 31

Тогда индексы будут принимать значения $`32 x + y`$ для всех $`0 \le x \le 31`$, значит будут
происходить обращения к памяти с промежутком в 32 ячейки, то есть 128 байт (если `sizeof(float) = 4`),
значит будет использовано 32 разных кеш-линий. Тогда в рабочей группе будет записано $`32^2 = 1024`$
кеш-линии.

### Пункт (c)

Аналогично пункту (a), но теперь со смещением 1. То есть будет записано две кеш-линии в
warp/wavefront. Тогда в рабочей группе будет записано 64 кеш-линии, если мы считаем, что каждая
кеш-линия записывается отдельно. Но если учесть, что первый warp/wavefront запишет 1 и 2 кеш-линии,
затем второй — 2 и 3 и т. д., то у нас каждая кеш-линия будет записана последовательно дважды,
и если это считать за одну запись, то получится 33 записи кеш-линии.
