# Задание 1 
Короткий ответ: первый вариант проще и быстрее реализовать.

Это происходит из-за того, что при его вычислении нет необходимости знать результат
вычисления одного work-item для вычисления другого. Для первого варианта 
достаточно один раз загрузить в видеопамять массив ``x`` и посчитать в каждом work-item
соответствующий ему ``y[i]``. 

Для эффективной реализации второго варианта придется писать некоторый алгоритм, 
похожий для вычисления префиксных сумм, который далеко не такой тривиальный и в любом
случае работает дольше.

# Задание 2
Короткий ответ: code divergence не будет

Исходя из написанного в условии рабочая группа будет исполняться на каждом warp следующим способом 
(приведены диапазоны ndrange индексов для исполняющихся work-itemов):
```
([0..31], 0, 0)
([0..31], 1, 0)
([0..31], 2, 0)
...
([0..31], 31, 0)
```
Давайте посчитаем значения переменной ``idx`` на каждом warp для исполняющихся work-itemов.
```
0 + 32 * [0..31]
1 + 32 * [0..31]
2 + 32 * [0..31]
...
31 + 32 * [0..31]
```

Очевидно, что если мы посмотрим на  ``idx % 32``, то это значение для всех work-item внутри одного warp 
будет одинаковым, тк второе слагаемое просто всегда делится на 32 и на деле на ``idx % 32`` влияет лишь ``get_local_id``, 
который в данном случае совпадает с номером warp.
Это значит, что все work-item будут исполнять код исключительно неотмаскированно, то есть code divergence не будет.
На первых 16 warp на всех потоках будет вызвана процедура ``foo``, а для следующих - ``bar``.

# Задание 3

## пункт (a)
Аналогично предыдущему заданию вычислим диапазон индексов, которые запрашиваются в рамках одного warp
```
[0..31] + 32 * 0
[0..31] + 32 * 1  
...
[0..31] + 32 * 31
```
Теперь зная ``sizeof(float) = 4`` можно вычислить запрашиваемые адреса на каждом warp(адреса относительно начала data):
```
[0..127]
[128..255]
...
[3968..4095]
```
Получается, что в каждом warp произойдет считывание лишь одной кеш-линии. Так как рабочая группа исполняется 32 warpа, 
на исполнение всей рабочей группы будет произведено считывание 32 рабочих линий. Доступ к памяти абсолютно coalesced.

## пункт (b)
Проделаем все аналогично предыдущему пункту:
```
0 + 32 * [0..31]
1 + 32 * [0..31]
...
32 + 32 * [0..31]
```
Теперь зная ``sizeof(float) = 4`` можно вычислить запрашиваемые адреса на каждом warp(адреса относительно начала data):
```
[0..3, 128..131, ... , 3968..3971]
[4..7, 132..135, ... , 3972..3971]
...
[124..127, 252..255, ... , 4092..4095]
```
Получается, что в каждом warp произойдет считывание 32 кеш-линий. Так как рабочая группа исполняется 32 warpа, 
на исполнение всей рабочей группы будет произведено считывание ``32 * 32 = 1024`` рабочих линий. Доступ к памяти абсолютно НЕ coalesced.

## пункт (c)
Проделаем все аналогично предыдущему пункту:
```
1 + [0..31] + 32 * 0
1 + [0..31] + 32 * 1  
...
1 + [0..31] + 32 * 31
```
Теперь зная ``sizeof(float) = 4`` можно вычислить запрашиваемые адреса на каждом warp(адреса относительно начала data):
```
[1..128]
[129..256]
...
[3969..4096]
```
Получается, что в каждом warp произойдет считывание 2 кеш-линий. Так как рабочая группа исполняется 32 warpа, 
на исполнение всей рабочей группы будет произведено считывание ``32 * 2 = 64`` рабочих линий. Доступ к памяти почти coalesced.
