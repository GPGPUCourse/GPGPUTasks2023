**1)**
Проще будет реализовать сигнал `y1`, так как формула подсчета для конкретного `i`-го элемента не зависит от остальных элементов `y1` -- достаточно разбить задачу на все доступные потоки и в каждом посчитать формулу.
Для подсчета `i`-ого элемента сигнала `y2` потребуются предыдущие `i - 1` и `i - 2`, поэтому нужно либо развернуть формулу (в конечном счете это будет какой-то полином от `x`, что усложнит подсчет), либо вычислять его последовательно.

**2)** Каждый варп будет состоять из workItem-ов одного столбца рабочей группы, т. е. для варпа `a` он будет состоять из workItem-ов `(i, a, 0)`, где `i` из `[0, 32)`. Тем самым получаем, что для одного варпа `get_local_id(1) == a`, `get_local_size(0) == 32` по условию, по этому `idx` сравним по модулю 32 с `a`, т. е. `idx % 32` одинаков для всех потоков варпа. Поэтому code divergence не произойдет.

**3)**
(a)
Повторяя рассуждения из прошлой задачи, получаем, что `get_local_size(0) == 32`, `get_local_id(1) == a`, для варпа, который работает с `(i, a, 0)` столбцом. Отсюда получаем, что формула пробегает последовательный непрерывный участок памяти размером 32 * 4 = 128 байт, т. е. один варп грузит всего лишь одну кэш-линию, т.е coalesced обращение к памяти. Соотвественно, в рабочей группе будет 32 кэш линии.

(b)
В этом случае потоки одного варпа загружают данные со сдвигом в 128 байт между workItem-ами, т. е. первый -- `x`-ый байт, следующий -- `x + 128` и так далее. Т. е. один варп грузит 32 кэш-линии, а рабочая группа -- 32 * 32 = 1024 кэш линии. Обращение к памяти совсем не coalesced.

(c)
Случай почти аналогичен случаю (a), с тем лишь исключением, что одному варпу теперь приходится загружать 2 соседние кэш-линии из-за сдвига, поэтому в целом обращение будет coalesced, а в одной рабочей группе загружается 64 кэш-линии.