### Задание 1

Первый сигнал может быть значительно проще и эффективнее реализован на GPU, так как вычисления независимы.

Во втором случае также можно ускорить выполнение с помощью параллельных вычислений, но с использованием более сложных алгоритмов.

### Задание 2

В k-м варпе (в 0-индексации) будут исполняться workitem-ы с 

```
id = (0,k,0), (1, k, 0) ... (31,k,0)
```

Для них значение 
```
idx = k + 32 * 0, k + 32 * 1 ... k + 32 * 31
```

Поэтому idx % 16 = k для каждого потока в варпе, значит, во всех потоках исполнение перейдёт в одну и ту же ветку и code divergence не произойдёт.

### Задание 3

(a)

В k-м варпе (в 0-индексации) будут исполняться workitem-ы с id = (i,k,0), где i = 0..31, k = const

Используемые ячейки массива имеют номера

```
get_local_id(0) + get_local_size(0) * get_local_id(1) = i + k * 32
```

То есть, произойдёт обращение к адресам

```
data + 4 * (32k + 0) = data + 128k
data + 4 * (32k + 1) = data + 128k + 4
...
data + 4 * (32k + 31) = data + 128k + 124
```

Соответствующие этим адресам float-ы образуют одну кеш-линию в памяти, поэтому будет записана 1 кеш-линия и доступ к памяти coalesced.

(b)

Используемые ячейки массива имеют номера

```
get_local_id(1) + get_local_size(1) * get_local_id(0) = k + i * 32
```

То есть, произойдёт обращение к адресам

```
data + 4 * (32 * 0 + k) = data + 4k
data + 4 * (32 * 1 + k) = data + 128 * 1+ 4k
...
data + 4 * (32 * 31 + k) = data + 128 * 124 + 4k
```

Соответствующие этим адресам float-ы лежат в 32 разных кеш-линиях, поэтому будут записаны 32 кеш-линии, и доступ к памяти не coalesced.

(c)

Используемые ячейки массива имеют номера

```
1 + get_local_id(0) + get_local_size(0) * get_local_id(1) = 1 + i + k * 32
```

То есть, произойдёт обращение к адресам

```
data + 4 * (32k + 1) = data + 128k + 4
data + 4 * (32k + 2) = data + 128k + 8
...
data + 4 * (32k + 32) = data + 128k + 128
```

Все float-ы, кроме последнего, лежат в одной кеш-линии, поэтому произойдёт запись в 2 кеш-линии и доступ к памяти coalesced.
