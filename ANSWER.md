# Задача 1

## Условие

Пусть на вход дан сигнал x[n], а на выход нужно дать два сигнала y1[n] и y2[n]:

```
 y1[n] = x[n - 1] + x[n] + x[n + 1]
 y2[n] = y2[n - 2] + y2[n - 1] + x[n]
```

Какой из двух сигналов будет проще и быстрее реализовать в модели массового параллелизма на GPU и почему?

## Решение

`y1[n]` можно посчитать независимо друг от друга, обращаясь только к `x[...]`,
поэтому их можно посчитать параллельно.

`y2[n]` зависит от `y2[0], ..., y2[n - 1]`, поэтому посчитать их независимо нельзя,
как нельзя и достичь большей скорости, чем при последовательном подсчёте за линейное время на CPU.

Таким образом, `y1[n]` будет проще и быстрее реализовать в модели массового параллелизма, чем `y2[n]`.

# Задача 2

## Условие

Предположим что размер warp/wavefront равен 32 и рабочая группа делится на warp/wavefront-ы таким образом что внутри warp/wavefront номер WorkItem по оси x меняется чаще всего, затем по оси y и затем по оси z.

Напоминание: инструкция исполняется (пусть и отмаскированно) в каждом потоке warp/wavefront если хотя бы один поток выполняет эту инструкцию неотмаскированно. Если не все потоки выполняют эту инструкцию неотмаскированно - происходит т.н. code divergence.

Пусть размер рабочей группы (32, 32, 1)

```c
int idx = get_local_id(1) + get_local_size(1) * get_local_id(0);
if (idx % 32 < 16)
    foo();
else
    bar();
```

Произойдет ли code divergence? Почему?

## Решение

Подставим константы:

```c
int idx = local_y + 32 * local_x;
if (idx % 32 < 16)
    foo();
else
    bar();
```

Можно заметить, что `local_x` не будет влиять на остаток от деления на 32, поэтому код можно представить как:

```c
if (local_y % 32 < 16)
    foo();
else
    bar();
```

То есть на выбор ветви исполнения влияет только `local_y`, но не `local_x`.
Поскольку размер warp равен 32, размер рабочей группы — (32, 32, 1), а номер по оси `x` меняется чаще всего,
то в пределах одного warp'а у потоков будет разным только `local_x`, а `local_y` будет одинаковым.

Следовательно, все потоки будут выполнять одну и ту же ветку,
**code divergence не произойдёт**.

# Задача 3

## Условие

Как и в прошлом задании предположим что размер warp/wavefront равен 32 и рабочая группа делится на warp/wavefront-ы таким образом что внутри warp/wavefront номер WorkItem по оси x меняется чаще всего, затем по оси y и затем по оси z.

Пусть размер рабочей группы (32, 32, 1).
Пусть data - указатель на массив float-данных в глобальной видеопамяти идеально выравненный (выравнен по 128 байтам, т.е. data % 128 == 0). И пусть размер кеш линии - 128 байт.

(a)
```
data[get_local_id(0) + get_local_size(0) * get_local_id(1)] = 1.0f;
```

Будет ли данное обращение к памяти coalesced? Сколько кеш линий записей произойдет в одной рабочей группе?

(b)
```
data[get_local_id(1) + get_local_size(1) * get_local_id(0)] = 1.0f;
```

Будет ли данное обращение к памяти coalesced? Сколько кеш линий записей произойдет в одной рабочей группе?

(c)
```
data[1 + get_local_id(0) + get_local_size(0) * get_local_id(1)] = 1.0f;
```

Будет ли данное обращение к памяти coalesced? Сколько кеш линий записей произойдет в одной рабочей группе?

## Решение
