# Выводы  
Всё отработало очень медленно, самую базовую реализацию на CPU получилось обойти только в трёх последних случаях (суммирование с главным потоком и два варианта суммирования деревом).  
На моём ноутбуке нет GPU, поэтому, вероятно, иполнение на "GPU" такое медленное. Поэтому не буду сравнивать между собой первые два CPU-варианта с остальными (стоит лишь отметить, что самым лучшим оказался вариант суммирования с главным потоком)  
1. Atomic add нереально медленный. Думаю, это связано как раз с тем, что все потоки одновременно идут прибавляь значение к результату, у них возникает очередь. В общем, долго.  
2. Что удивило - так это то, что цикл отработал ещё дольше. Наверное, дело в том, что тут не coalesced memory access.  
3. Если сделать coalesced цикл, то работает уже лучше (что логично), в среднем чуть лучше, чем бейзлайн.  
4. Главный поток всех порвал! Во-первых, тут один варп обраается как раз к 32 ячейкам памяти, тут должно быть coalesced. К тому же, тут используется local массив для ворк группы.  
5. Дерево. Вариант 1 - это с однократным запуском ядра. Отработало хуже главного потока, но тоже неплохо. Почему - не знаю, вероятно, цикл для главного потока (когда считается сумма для ворк группы) не оправдывает себя.  
6. Дерево с многократным запуском ядра. Ещё хуже, но всё ещё относительно неплохо. Портить картину может цикл с многократным запуском ядра, но ещё очень важно, что приходится ещё дополнительно копировать весь массив из *as_gpu* в *bs_gpu* перед каждой итерацией. А это долго, так как массив большой.