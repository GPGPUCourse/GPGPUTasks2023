В этом репозитории предложены задания для курса по вычислениям на видеокартах 2023.

[Остальные задания](https://github.com/GPGPUCourse/GPGPUTasks2023/).

Сдача задания текстом через пулл-реквест в эту ветку, созданием файла ANSWER.md.

# Задание 2. Теоретическое задание: параллелизуемость/code divergence/memory coalesced access

Ниже три небольших задачи. Рекомендуется хотя бы начать делать каждое задание к лекции 15 сентября, чтобы задать вопросы если они будут и обсудить задания. **Дедлайн**: 23:59 24 сентября.

**1)** Пусть на вход дан сигнал x[n], а на выход нужно дать два сигнала y1[n] и y2[n]:

```
 y1[n] = x[n - 1] + x[n] + x[n + 1]
 y2[n] = y2[n - 2] + y2[n - 1] + x[n]
```

Какой из двух сигналов будет проще и быстрее реализовать в модели массового параллелизма на GPU и почему?

_Решение:_ второй сигнал сложнее реализовать в модели массового параллелизма, так как для вычисления **y2[n]** необходимо, чтобы прошлые два значения **y2[n - 2]**, **y2[n - 1]** сигнала **y2** были уже подсчитаны. Напротив, для вычисления значений сигнала **y1** достаточны лишь значения сигнала **x**, которые известны и подаются на вход.

**2)** Предположим что размер warp/wavefront равен 32 и рабочая группа делится
 на warp/wavefront-ы таким образом что внутри warp/wavefront
 номер WorkItem по оси x меняется чаще всего, затем по оси y и затем по оси z.

Напоминание: инструкция исполняется (пусть и отмаскированно) в каждом потоке warp/wavefront если хотя бы один поток выполняет эту инструкцию неотмаскированно. Если не все потоки выполняют эту инструкцию неотмаскированно - происходит т.н. code divergence.

Пусть размер рабочей группы (32, 32, 1)

```
int idx = get_local_id(1) + get_local_size(1) * get_local_id(0);
if (idx % 32 < 16)
    foo();
else
    bar();
```

Произойдет ли code divergence? Почему?

_Решение:_ исходя из формулы, значение **idx** зависит только от координат **WorkItem** по оси **x** и **y**. Также стоит заметить, что размер **WorkGroup** по оси **z** равен **1**, а это значит что итерации по оси **z** не будет. При этом в условии говорится, что значение **WorkItem** по **x** меняется чаще, чем по **y**. 

Значит на любом вызове **kernel** вызовы функции **get_local_id(0)** будут возвращать **0..31** для **32** потоков. С другой стороны - **get_local_id(1)** на первом вызове вернет **0**, на втором - **1**, на последнем **31**. 

Значит значения **idx** на первом вызове **kernel** будут равны **0**, **32**, .., **992**. Остаток от деления на **16** этих чисел равен **0**, следовательно, на первой вызове **kernel** **code divergence** не будет.

На втором вызове **kernel** значения **idx** будут равны **1**, **33**, .., **993**. Остаток от деления на **16** этих чисел равен **1**, следовательно, и при втором вызове **kernel** **code divergence** не будет.

На последнем вызове **kernel** значения **idx** будут равны **31**, **63**, .., **1023**. Остаток от деления на **16** этих чисел равен **31**, следовательно, и на последнем вызове **kernel** **code divergence** не будет.

Таким образом **code divergence** не произойдет.

**3)** Как и в прошлом задании предположим что размер warp/wavefront равен 32 и рабочая группа делится
 на warp/wavefront-ы таким образом что внутри warp/wavefront
 номер WorkItem по оси x меняется чаще всего, затем по оси y и затем по оси z.

Пусть размер рабочей группы (32, 32, 1).
Пусть data - указатель на массив float-данных в глобальной видеопамяти идеально выравненный (выравнен по 128 байтам, т.е. data % 128 == 0). И пусть размер кеш линии - 128 байт.

(a)
```
data[get_local_id(0) + get_local_size(0) * get_local_id(1)] = 1.0f;
```

Будет ли данное обращение к памяти coalesced? Сколько кеш линий записей произойдет в одной рабочей группе?

_Решение:_ данное обращение будет **coalesced**. Так как индексы, к которым происходят обращения будут следовать непрерывно.

8 - кеш линий записей произойдет в одной рабочей группе. При условии, что если результат записи кеша сохраняется для различных вызовов **kernel**.

(b)
```
data[get_local_id(1) + get_local_size(1) * get_local_id(0)] = 1.0f;
```

Будет ли данное обращение к памяти coalesced? Сколько кеш линий записей произойдет в одной рабочей группе?

_Решение:_ данное обращение не будет **coalesced**. При каждом вызове **kernel** получим индексы, что каждый следующий больше предыдущего индекса на **32**. Тогда для каждого вызова необходимо **1024/128=8** записей кеш линий. Всего таких вызовов **32**.

256 - кеш линий записей произойдет в одной рабочей группе

(c)
```
data[1 + get_local_id(0) + get_local_size(0) * get_local_id(1)] = 1.0f;
```

Будет ли данное обращение к памяти coalesced? Сколько кеш линий записей произойдет в одной рабочей группе?

_Решение:_ данное обращение будет **coalesced**. Так как самый наибольший индекс равен **1024**, и при обращении к нему загрузится еще одна кеш-линия.

9 - кеш линий записей произойдет в одной рабочей группе
