В этом репозитории предложены задания для курса по вычислениям на видеокартах 2023.

[Остальные задания](https://github.com/GPGPUCourse/GPGPUTasks2023/).

Сдача задания текстом через пулл-реквест в эту ветку, созданием файла ANSWER.md.

# Задание 2. Теоретическое задание: параллелизуемость/code divergence/memory coalesced access

Ниже три небольших задачи. Рекомендуется хотя бы начать делать каждое задание к лекции 15 сентября, чтобы задать вопросы если они будут и обсудить задания. **Дедлайн**: 23:59 24 сентября.

**1)** Пусть на вход дан сигнал x[n], а на выход нужно дать два сигнала y1[n] и y2[n]:

```
 y1[n] = x[n - 1] + x[n] + x[n + 1]
 y2[n] = y2[n - 2] + y2[n - 1] + x[n]
```

Какой из двух сигналов будет проще и быстрее реализовать в модели массового параллелизма на GPU и почему?

**Ответ:**

Проще реализовать будет сигнал y1[n] поскольку он зависит только от значений x[n - 1], x[n] и x[n + 1]
которые известны каждому потоку с самого начала алгоритма, поэтому никакой зависимости между потоками не возникает.

Для простой реализации сигнала y2[n] потребуется 
можно синхронизировать потоки, чтобы знать значения y2[n - 2] и y2[n - 1] на момент начала выичсления сигнала,
либо можно явно рассчитывать все предыдущие значения в каждом потоке, оба варианта делают использование GPU для
вычисления данного сигнала нецелесообразным.


**2)** Предположим что размер warp/wavefront равен 32 и рабочая группа делится
 на warp/wavefront-ы таким образом что внутри warp/wavefront
 номер WorkItem по оси x меняется чаще всего, затем по оси y и затем по оси z.

Напоминание: инструкция исполняется (пусть и отмаскированно) в каждом потоке warp/wavefront если хотя бы один поток выполняет эту инструкцию неотмаскированно. Если не все потоки выполняют эту инструкцию неотмаскированно - происходит т.н. code divergence.

Пусть размер рабочей группы (32, 32, 1)

```
int idx = get_local_id(1) + get_local_size(1) * get_local_id(0);
if (idx % 32 < 16)
    foo();
else
    bar();
```

Произойдет ли code divergence? Почему?

**Ответ:**

Нет, поскольку рабочая группа делится на warp-ы так, что на warp-е будут WorkItem-ы с одинаковыми значениями 
get_local_id(1) и 32-я различными значениями get_local_id(0), при этом get_local_size(1) = 32, то есть
все потоки одного warp-а будут иметь одинаковое значение idx % 32, поэтому на всех потоках будет отрабатывать
одна и та же ветка, поэтому code divergence не будет.


**3)** Как и в прошлом задании предположим что размер warp/wavefront равен 32 и рабочая группа делится
 на warp/wavefront-ы таким образом что внутри warp/wavefront
 номер WorkItem по оси x меняется чаще всего, затем по оси y и затем по оси z.

Пусть размер рабочей группы (32, 32, 1).
Пусть data - указатель на массив float-данных в глобальной видеопамяти идеально выравненный (выравнен по 128 байтам, т.е. data % 128 == 0). И пусть размер кеш линии - 128 байт.

(a)
```
data[get_local_id(0) + get_local_size(0) * get_local_id(1)] = 1.0f;
```

Будет ли данное обращение к памяти coalesced? Сколько кеш линий записей произойдет в одной рабочей группе?

**Ответ:**

Аналогично прошлому заданию на warp-е будут WorkItem-ы с одинаковыми значениями 
get_local_id(1) и 32-я различными значениями get_local_id(0), при этом get_local_size(1) = 32.
Поскольку data % 128 == 0 и (32 * get_local_id(1)) % 32 == 0, то мы за одно обращение к памяти запишем 
последовательных 32 значения (так как размер float - 4 байта).

То есть запрос будет coalesced, и произойдет одно обращение к памяти (данные покрываются одной кеш линией).


(b)
```
data[get_local_id(1) + get_local_size(1) * get_local_id(0)] = 1.0f;
```

Будет ли данное обращение к памяти coalesced? Сколько кеш линий записей произойдет в одной рабочей группе?


**Ответ:**

В данном случае обращение к памяти не будет coalesced, поскольку будут записаны значения с шагом 32 
(так как get_local_size(1) = 32 и get_local_id(1) одинаковый в рамках warp-а.
Всего будет 32 обращения к памяти поскольку никакие два запроса не покроются одной кэш линией.


(c)
```
data[1 + get_local_id(0) + get_local_size(0) * get_local_id(1)] = 1.0f;
```

Будет ли данное обращение к памяти coalesced? Сколько кеш линий записей произойдет в одной рабочей группе?

**Ответ:**

В данном случае все аналогично пункту (a), однако придется сделать два запроса, поскольку 
первые 31 запросов покрываются одной кеш линией, а для последнего придется делать 
дополнительный запрос из-за сдвига на 1.