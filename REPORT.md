**1)** Берем реализацию на процессоре без OpenMP в качестве базовой, так как у меня нет драйверов для AMD видеокарты, и "GPU" будет на самом деле интегрированной видекартой на процессоре.

`CPU:     363.976 millions/s`

**2)** C директивами OpenMP все сильно лучше, так как код параллелится на 8 ядер, и получаем пятикратное ускорение

`CPU OMP: 1545.82 millions/s`

**3)** Что характерно, на "GPU" с атомарным сложением все настолько плохо, что в три раза медленнее, чем на процессоре. Полагаю, что это связано с накладными расходами на реализацию OpenCL API (кэши те же, что и у процессора, раз это интегрированная видеокарта) и возможным остутствием каких-либо оптимизаций компилятора вследствие этого

`GPU global atomic: 108.206 millions/s`

**4)** Сложение в цикле работает еще чуть медленнее атомарного, скорее всего сумма в пределах одной ворк группы работает сильно быстрее, чем атомарное прибавление, поэтому мы даже ухудшили время (возможно стоит увеличить размер рабочей группы)

`GPU cycle: 90.416 millions/s`

**5)** Coalesced доступ к памяти сделал чуть лучше, но ненамного (полагаю, по той же причине)

`GPU cycle coalesced: 91.3169 millions/s`

**6)** Лучшая реализация, копирование в локальную память и coalesced доступ к памяти одним потоком группы

`GPU local memory: 4080.38 millions/s`

**7)** Предположительно долго из-за частых барьеров и плохого расположения в памяти

`GPU atomic tree: 655.187 millions/s`

**8)** К предыдущему добавляется еще и необходимость копировать большой массив для перезапуска кернела

`GPU tree: 162.266 millions/s`