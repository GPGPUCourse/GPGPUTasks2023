**1)** Берем реализацию на процессоре без OpenMP в качестве базовой, так как у меня нет драйверов для AMD видеокарты, и "GPU" будет на самом деле интегрированной видекартой на процессоре.

`CPU:     363.976 millions/s`

**2)** C директивами OpenMP все сильно лучше, так как код параллелится на 8 ядер, и получаем пятикратное ускорение

`CPU OMP: 1545.82 millions/s`

**3)** Что характерно, на "GPU" с атомарным сложением все настолько плохо, что в три раза медленнее, чем на процессоре. Полагаю, что это связано с накладными расходами на реализацию OpenCL API (кэши те же, что и у процессора, раз это интегрированная видеокарта) и возможным остутствием каких-либо оптимизаций компилятора вследствие этого

`GPU global atomic: 108.206 millions/s`

**4)** Сложение в цикле работает сильно лучше атомарного прибавления, примерно в 40 раз

`GPU cycle: 4495.36 millions/s`

**5)** Лучшая реализация с сoalesced доступом

`GPU cycle coalesced: 4615.56 millions/s`

**6)** Копирование в локальную память и coalesced доступ к памяти одним потоком группы работает чуть хуже сложения цикле

`GPU local memory: 4080.38 millions/s`

**7)** Предположительно долго из-за частых барьеров и плохого расположения в памяти

`GPU atomic tree: 655.187 millions/s`

**8)** К предыдущему добавляется еще и необходимость копировать большой массив для перезапуска кернела

`GPU tree: 162.266 millions/s`