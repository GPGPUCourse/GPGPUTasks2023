Итак, у меня получились такие результаты:
```commandline
CPU:     0.229506+-0.000695267 s
CPU:     435.719 millions/s
CPU OMP: 0.0952463+-0.00243946 s
CPU OMP: 1049.91 millions/s
OpenCL devices:
  Device #0: CPU. 11th Gen Intel(R) Core(TM) i5-1145G7 @ 2.60GHz. Intel(R) Corporation. Total memory: 15672 Mb
  Device #1: GPU. Intel(R) Iris(R) Xe Graphics. Total memory: 12537 Mb
Using device #1: GPU. Intel(R) Iris(R) Xe Graphics. Total memory: 12537 Mb
GPU (atomic sum): 0.0188547+-0.0005158 s
GPU (atomic sum): 5303.73 millions/s
GPU (loop sum): 0.0441702+-7.85354e-05 s
GPU (loop sum): 2263.97 millions/s
GPU (loop coalesced sum): 0.0344518+-0.000566793 s
GPU (loop coalesced sum): 2902.6 millions/s
GPU (Sum With Local Memes): 0.0175792+-0.000112011 s
GPU (Sum With Local Memes): 5688.55 millions/s
GPU (tree sum): 0.017827+-0.000294723 s
GPU (tree sum): 5609.47 millions/s
```
Пока я это писал, сильно удивился, что у меня есть 
видеокарта, думал, что Intel(R) Iris(R) Xe Graphics - это 
графическое ядро в процессоре, не более того, а 
оказывается это дискретная видюшка для офисных ноутов.

Как я и ожидал суммирования деревой и суммирование с 
~~локальными мемами~~ локальной памятью будут быстрее 
остальных, но я не ожидал, что atomic sum будет таким же 
быстрым методом.

Почему atomic sum оказался почти наравне с деревом и
локальной памятью с главным потоком, я не понимаю.
Следуя логике и тому, что было на лекции, он должен быть 
если не самым медленным, то по крайней мере почти самым 
медленным, так как должна получаться очередь на сложение

Далее циклы, я ожидал, что они будут медленнее дерева, 
так как они плохо масштабируются из-за
того, что мы много сложений делаем в одном потоке. 
Ко всему прочему на этом примере видна разница в coalesced
и не coalesced доступе к памяти (coalesced, очевидно быстрее, 
но не радикально)

Главный поток и дерево получились +- одинаково быстрыми,
как я и ожидал. Дерево замечательно из-за того, что в нём в
одном потоке происходит всего $\log(\text{WORKGROUP_SIZE})$ 
сложений, а затем $\frac{\text{array_size}}{\text{WORKGROUP_SIZE}}$
атомарных добавлений, которые как выяснилось не сильно влияют
на производительность (почему-то).

В случае главного потока я не понимаю, откуда такая огромная разница с 
coalesced циклом. Неужели подгрузка в локальный массив ворк группы 
даёт такую разницу по времени? Но, тем не менее, использование она даёт свои результаты